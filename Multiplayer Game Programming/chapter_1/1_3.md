# 에이지 오브 엠파이어

트라이브스와 비슷한 시기에 RTS 게임인 에이지 오브 엠파이어가 출시 되었다.
동시기에 출시되다 보니 에이지 오브 엠파이어 또한, 비슷한 대역폭 문제와 인터넷 전화 접속의 레이턴시 문제를 안고 있었다.
에이지 오브 엠파이어는 결정론적 락스텝 모델을 채택했는데, 이 모델에선 컴퓨터 하나하나가  P2P 방식으로 다른 모든 컴퓨터에 연결하는 방식을 채용했다.
결정론이 보장된느 게임에선 모든 피어가 각각 동시에 병행하여 시뮬레이션을 진행한다. 그리고 게임이 진행되는 내내 모든 피어의 동기화를 맞추기 위해 통신에 락스텝을 사용한다.
트라이브스의 사례와 유사하게, 결정론적 락스텝 모델도 오랫동안 여러 게임에서 사용됐고, 최신 RTS 게임에서도 여전히 쓰이는 기술이다. 이후 만들어 볼 볼 로보캣 RTS 게임도 결정론적 락스텝 모델로 구현해 보겠다.

RTS 멀티플레이어 게임을 네트워킹으로 구현하는데 있어 FPS와 비교해 가장 큰 차이점은 플레이어의 가시권에 포함되는 유닛의 개수가 많다는 점이다. 
트라이브스의 경우 128명을 꽉 채워 플레이한다 해도 어느 시점에 특정 클라이언트 하나에 보여지는 플레이어의 수는 비교적 적은 수에 불과하기 마련이다.
트라이브스에서 고스트 매니저가 한 번에 처리할 고스트의 숫자는 20에서 30건 정도가 고작이다.

이를 에이지 오브 엠파이어 같은 RTS 게임과 비교해 보자. 한번에 접속하는 플레이어 수는 훨씬 적지만, 각 플레이어는 저마다 많은 수의 유닛을 운용한다. 
방을 만들고 게임을 막 시작하는 시점엔 플레이어마다 50마리씩 만들 수 있고, 게임 후반으로 가면 최대 200마리까지 만들 수 있다.
50마리라 해도 8명이 참가하는 큰 판에선, 최대 400 유닛이 게임 내에서 돌아다니는 셈이다. 
가시권 판정을 절묘하게 하는 알고리즘이 있어서 동기화 할 유닛의 숫자를 효율적으로 다룰 수 있다 치더라도, 최악의 경우를 따져볼 필요가 있다.
만일 게임 후반 플레이어 8명이 모두 그간 쌓아둔 유닛을 총동원해 한 장소에서 격돌하면 어떻게 될까
그러면 한 번에 천 단위 숫자의 유닛이 동시에 가시권에 들어오게 될 것이다. 유닛당 정보를 아무리 최소화하더라도 이렇게 많은 유닛의 정보를 동기화하기는 매우 어려운 일이다.

이 같은 문제를 해결하기 위해 에이지 오브 엠파이어 개발자들은 개별 유닛을 하나하나 동기화하는 대신 플레이어가 입력한 명령을 동기화 하기로 했다.
얼핏 작은 차이처럼 보이지만 이는 매우 중요한 설계상 결정이다. RTS 프로게이머라 하더라도 분당 300회 이상의 명령을 내리기는 어렵다.
다시 말해 아무리 극단적인 경우라도 게임 시스템이 플레이어마다 초당 몇 회 정도의 명령만 전송할 수 있으면 충분하다. 이 정도면 수백 유닛의 정보를 보내는 것보단 대역폭 관리가 훨씬 수월한 분량이 된다.
그렇지만 유닛 정보를 네트워크를 통해 보내지 않으므로 모든 플레이어의 게임 인스턴스는 명령을 받으면 그 명령대로, 스스로 게임 시뮬레이션을 진행해야 한다.
게임 인스턴스마다 시뮬레이션을 독자적으로 수행하게 되므로 각 인스턴스를 다른 인스턴스와 정확히 동기화 할 수 있는지가 극도로 중요해진다.
결정론적 락스텝 모델을 구현하는데 있어 가장 어려운 과제가 바로 이것이다.

# 턴 타이머

각 게임 인스턴스마다 독립적으로 시뮬레이션을 수행하므로 P2P형태 의 토폴로지가 잘 어울린다. 
6장에서 논의하겠지만, P2P 모델에선 컴퓨터 사이에 데이터가 비교적 빠르게 오갈 수 있다는 장점이 있다. 서버가 중간에서 데이터를 중개할 필요가 없기 때문이다.
하지만 각 플레이어가 각자의 정보를 서버 하나에 보내는 데 그치지 않고 다른 모든 플레이어에게 전송해야 한다는 단점이 있다.
예를 들어, 플레이어 A가 공격 명령을 내릴 때 다른 모든 인스턴스가 이 공격을 인지할 수 있게끔 플레이어 A의 피어는 다른 모든 피어에 정보를 보내야 하고, 모두 정확히 같은 시점에 이 명령을 처리해야 한다.
그렇지 않으면 각 인스턴스의 시뮬레이션이 그 시점부터 발이 안 맞기 시작한다.

그렇지만 여기서 한 가지 중요한 점을 간과해선 안 되는데, 각 플레이어의 게임은 저마다 다른 프레임 레이트로 구동되고, 접속 환경도 품질이 서로 차이가 날 수밖에 없다는 점이다.
앞서 플레이어 A가 공격 명령을 내리는 시나리오의 문제점을 고려해 개선해 보자. 
A가 명령을 내릴 때 곧바로 적용해 버리는 대신, 명령을 잠깐 대기시켜 둔 채로 일단 B, C, D에 보내어 모두가 준비되었을 때 비로소 동시에 적용하는 것이다.
하지만 여기에도 골치 아픈 문제가 있다. 플레이어 A의 공격 명령이 너무 오랫동안 처리되지 않으면 게임이 매우 지척거리는 응답 속도를 보인다는 것이다.

이에 대한 해결책은 바로, 턴 타이머를 추가하여 일정 기간마다 명령을 쌓아두는 것이다. 턴 타이머 방식으로 구현하기 위해선 먼저 턴의 길이를 정해 두어야 한다.
에이지 오브 엠파이어의 경우 턴의 기본 길이를 200밀리초로 잡았다. 이 200밀리초 동안 모든 명령은 대기열 버퍼에 쌓인다.
200밀리초가 지나면 턴이 완료되어 그동안 대기열에 쌓아둔 그 플레이어의 모든 명령이 다른 플레이어들에게 전송된다.
여기서 핵심은 수신 측이 명령 대기열을 받는 즉시 처리하지 않고, 이후 두번의 턴이 지난 다음에 처리한다는 것이다.
예를 들어 50번째 턴에 내려진 명령들을 인스턴스가 저마다 받아서 가지고 있다가 52번째 턴에 실행하는 식으로 말이다.
200밀리초짜리 타이머의 경우 인풋 랙, 즉 입력 후 화면에 반영하기까지 지연시간이 모두 합쳐 최대 600밀리초가 되는 셈이다. 하지만 지연시간에도 불구하고 딱 두턴만 기다려주면 모든 플레이어가 명령을 받아 동시에 그 턴을 처리하는 데 큰 문제가 없게 된다.
이처럼 명색이 '실시간'인 RTS 게임이 알고 보니 턴제로 구현된다는 점이 역설적으로 느껴질지 모르지만, 턴 타이머 기법은 이미 스타크래프트2 등 여러 RTS 게임에서 널리 검증된 기법이다. 
물론 요즘 게임은 90년대 후반에 비해 대역폭과 레이턴시 면에서 우수한 네트워크 환경을 넉넉하게 활용 가능하므로 더 짧은 간격의 턴 타이머를 구동할 수 있다.

턴 타이머 방식에서 고려해야 할 마지노선이 있다. 플레이어 한 명에게 심한 랙이 발생하여 200밀리초 타이머조차도 따라가지 못하는 경우엔 어떻게 처리해야 할까.
어떤 게임은 시뮬레이션을 잠시 중단하여 랙을 극복할 기회를 준다. 해당 플레이어가 지속적으로 랙을 유발하여 게임 진행에 지장을 준다면 플레이어를 내보내도록 처리할 수도 있다. 
에이지 오브 엠파이어는 이 같은 경우가 발생하는 것을 최소화하기 위해 렌더링 프레임 레이트를 때에 따라 동적으로 조절하는 메커니즘을 채택했다.
즉, 인터넷 연결이 느린 컴퓨터에선 네트워크 데이터 수신에 시간을 더 할애하고, 그래픽 렌더링의 품질을 저하시키기도 하는 것이다.
턴 타이머를 동적으로 조절하는 상세한 기법은 1.6절에서 베트너와 터래노의 논문을 참고하자.

이렇게 클라이언트가 입력한 명령을 모아 보내는 방식엔 또 한 가지 장점이 있다. 경기 진행 내내 처리된 모든 입력을 모아 저장해 두더라도 메모리 용량이나 그 처리 부담이 적다는 점이다.
덕택에 에이즈 오브 엠파이어 2에는 경기 진행 리플레이를 저장하는 기능을 추가할 수 있었다. RTS 장르에서 리플레이 기능은 인기가 높은 편인데, 플레이어들이 경기 내용을 돌려보고 전략을 깊이 분석해 볼 수 있기 때문이다.
명령대신 유닛 정보를 일일이 담는 방식이엇다면 리플레이를 저장하는데 훨씬 많은 메모리가 필요하고 오버헤드도 심했을 것이다.

# 동기화

턴 타이머만으로는 각 피어 사이의 동기화를 확실하게 보장하기 어렵다. 각 머신이 명령을 받아 독립적으로 처리하므로, 이들 기기가 항상 같은 결과로 수렴토록 보장하는 장치가 절대적으로 중요하다.
베트너와 터래노가 논문에 다음과 같이 기술한 내용을 참고해 보자.

"동기화가 어긋나는 오류를 찾기 어려운 이유는 피어마다 미세한 오차가 누적될 수 있다는 데서 비롯된다. 무작위로 생성한 맵에 배치된 사슴의 위치가 미세하게 어긋난 경우를 가정해보자.
몇 분 뒤 마을 주민이 사슴을 사냥하러 쫓아갈 때 그 오차로 인해 경로가 약간 달라질 수 있는데, 이때문에 각 피어에서 똑같이 창을 던져도 어떤 피어에선 범위를 아슬아슬하게 빗나가 사냥에 실패하고 따라서 그 피어만 식량 확보에 실패하는 식으로 연쇄 반응이 이어질 수 있다."

대부분 게임은 행동의 결과에 약간의 임의성을 부여하는 경우가 많다. 이 점을 고려하여 생각해볼 예제가 있는데, 게임 내 궁수가 보병을 명중시킬지 여부를 난수로 검사한다고 치자.
만일 플레이어 A의 인스턴스에선 궁수가 보병을 명중시켰는데, 플레이어 B의 인스턴스에선 명중하지 않았다면 즉각 플레이어의 눈에 띌 것이다.
이 문제를 해결하기 위해 유사 난수 발생기의 동작 원리에 주목해 보자.
유사 난수 발생기는 완벽한 난수가 아니라 어디까지나 난수와 '유사한' 값을 도출하는데, 난수를 도출할 때 어던 형태이건 시드값, 즉 난수의 씨앗이 되는 값에서 유도하여 도출하므로 모든 게임 인스턴스의 시드값만 똑같이 맞춰 주면 플레이어 A와 B 모두에서 같은 난수 결과가 도출되도록 보장할 수 있다.
단, 이때 명심할 점은 시드 값을 통일해 두어도 단 한번이라도 서로 다른 횟수로 호출하면 더 이상 회차마다 같은 값이 나오지 않게 된다는 점이다.
그러므로 시드 값을 동기화하는 것도 중요하지만, 각 게임 인스턴스가 서로의 난수 발생기를 같은 횟수로 호출해야 한다는 것 또한 중요하다. 그러지 않으면 난수 결과가 서로 어긋나 동기화가 깨지게 된다.
P2P환경에서 유사 난수 발생기를 사용해 동기화하는 기법에 대해선 6장에서 더 알아보자.

동기화를 검사할 때 잠재적인 이점이 하나 있다. 치트를 쓰기가 원천적으로 어려워진다는 것이다.
예를 들어 어떤 플레이어가 추가 자원 500을 치트로 획득하면 다른 인스턴스가 이를 즉각 알아챌 수 있는데, 치트로 인해 게임 상태의 동기화가 깨지기 때문이다. 이렇게 치트를 쓰는 플레이어를 일단 감지하면 쉽게 게임에서 쫓아낼 수 있다.
한편으론 반대급부도 있는데, 동기화 시스템은 보여주어선 안 될 정보를 드러내 버리는 종류의 치트에는 무방비하다는 단점이 있다.
소위 '맵핵'이라 불리는 치트 프로그램은 맵 전체를 다 훔쳐볼 수 있게 해 주는데, 이는 RTS 게임에 있어 오늘날에도 흔한 골칫거리이다. 이를 비롯해 여러 보안 관련 사항에 대해서는 10장에서 더 살펴보자.
