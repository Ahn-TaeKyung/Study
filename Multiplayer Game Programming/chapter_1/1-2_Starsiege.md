# 스타시즈: 트라이브스

스타시즈: 트라이브스는 1998년 말에 출시된 SF 장르 FPS다.

빠른 템포의 전투와 당시 기준으로 대규모 접속 가능한 게임 모드를 제공하여 랜이나 인터넷으로 플레이할 수 있었다. 
당시 기술로 이 인원을 수용한다는 것은 실로 엄청나게 어려운 일이었는데, 단적인 예로 대부분 플레이어가 인터넷을 전화 접속으로 하던 시절이다.
전화 접속용 모뎀의 속도는 기껏해야 56.6kbps밖에 되지 않았는데, 트라이브스는 심지어 28.8kbps 모뎀을 가진 유저도 플레이할 수 있었다.

앞으로 만들어 갈 예제 게임인 로보캣 액션도 궁극적으론 트라이브스의 네트워킹 모델을 따라 설계하였으니 참고하자.

네트워크 게임을 설계할 때 가장 먼저 정해둘 것은 통신 프로토콜이다. 여기서 프로토콜이란 두 대의 컴퓨터 사이에 어떤 데이터가 오고 갈지를 정해둔 규약이다.
2장에서 인터넷의 동작원리와 인터넷에 주로 사용되는 프로토콜을 다룬다.
3장 에선 이들 프로토콜을 제어하는데 가장 널리 쓰이는 라이브러리인 버클리 소켓을 자세히 살펴본다.
일단, 트라이브스는 효율성 문제로 비신뢰성 프로토콜을 사용한다는 정도만 알아두자. 즉, 네트워크로 보낸 데이터가 수신자에게 반드시 도착한다는 보장이 없다는 뜻이다.

하지만 게임에 참여한 모든 플레이어에게 중요한 정보까지도 모조리 비신뢰성 프로토콜로 보내면 문제가 야기될 수 있다.
따라서 개발할 때 데이터의 종류에 따라 어떻게 보낼지를 구분해 두어야 한다.

트라이브스를 개발하는 과정에선 크게 다음 네가지 종류로 데이터 전송의 요구 사항을 구분했다.

1. 전달 미보장 데이터

말 그대로 게임에 있어 그다지 중요하지는 않은 데이터를 지칭한다. 대역폭이 고갈되면 게임 시스템은 이런 종류의 데이터부터 생략해 버린다.

2. 전달 보장 데이터

수신이 보장되어야 하며 나아가 데이터가 보낸 순서대로 도착하는 것도 보자오디어야 하는 데이터이다.
게임에 있어 매우 중요하다고 판단되는 데이터로, '플레이어가 총을 발사했다'는 이벤트가 그 예이다.

3. 최신 상태 데이터

최신 상태가 아니면 전달할 의미가 없는 성격의 데이터이다. 예를 들면 특정 플레이어의 체력 수치가 그렇다.
지금 현재 HP를 알고 있다면 5초 전의 HP가 얼마였는지는 굳이 전달할 필요가 없다.

4. 특급 전달 보장 데이터

최우선으로 보내야 하며 아울러 전달이 보장되어야 하는 데이터가 여기에 속한다.
플레이어 위치 정보가 그 예로, 시간이 지체될수록 정보의 가치가 급격히 떨어지므로 최대한 빨리 전달해야 한다.

트라이브스가 사용한 네트워킹 모델에선 이들 네 종류의 데이터 성격에 따라 여러 세부사항을 결정했다.

또 한가지 중요한 결정사항은 바로 <피어-투-피어: P2P> 대신 <클라이언트-서버:CS> 모델을 채택한 것이다.
CS모델에서는 모든 플레이어가 중앙 서버 하나에 접속하는 데 반해, P2P 모델에선 각각의 플레이어가 모든 플레이어와 연결을 유지해야 한다.
6장에서 더 논의하겠지만, P2P 모델은 O(n2)의 대역폭이 필요하다.  이는 사용자 수의 제곱에 비례하여 대역폭이 소모된다는 뜻이다.
이 경우 n, 즉 사용자 수가 128이라면 P2P 연결 시 각각의 플레이어는 주어진 대역폭을 n 제곱인 16,384로 나눠 써야 하는 셈이다. 

이 같은 문제를 피하고자 트라이브스에선 CS 모델을 채택했다. 클라이언트-서버로 구성하면 각 플레이어에 할당되는 대역은 상수로 고정되며, 서버만 O(n) 대역폭을 처리하면 된다.
그렇지만 이는 곧 서버가 들어오는 연결을 모두 받아줄 수 있을 정도로 강력해야 함을 뜻하는데, 당시 그 정도의 회선은 기업이나 대학만이 보유할 법한 사양이었다.

이제 트라이브스에서 네트워크를 어떻게 여러 계층으로 나누었는지 살펴보자. 트라이브스의 네트워킹 모델은 '시루떡 처럼 쌓아 올린' 모양 즉, 스택이라 보면 되며 다음 그림으로 묘사했다.
이후 내용으로 이들 각 계층이 어떻게 구성되는지 설명하고자 한다.

<img src="https://github.com/user-attachments/assets/f6a793be-dd3b-4a2e-9ae7-15e45e4ced7d" width="500">

# 플랫폼 패킷 모듈

패킷이란 네트워크로 보내기 위해 데이터를 묶어 놓은 한 단위를 말한다. 트라이브스 모델 최하위 계층은 플랫폼 패킷 모듈이다.
이 모듈은 여러 계층 중 유일하게 플랫폼 종속적인 계층이기도 하다. 이 계층은 본질적으론 표준 소켓 API를 래핑 즉, 감싸둔 것에 불과한데, 다양한 패킷 형식을 조립하고 전송하려는 목적으로 래핑한 것이다.
그래서 구현 내용을 보면 3장에 소개될 시스템과 유사하다.

트라이브스는 비신뢰성 프로토콜을 사용하므로, 전달이 보장되어야 하는 데이터 처리를 위해 몇 가지 메커니즘을 추가할 필요가 있었다. 
7장에서도 비슷하게 풀어갈 테지만, 트라이브스 개발자들은 신뢰성 계층을 직접 구현하기로 했다.
그렇다고 이 처리를 플랫폼 패킷 모듈에서 다 하는 건 아니다. 보다 상위 계층의 고스트 관리자, 이동 관리자, 이벤트 관리자가 신뢰성 관련된 처리를 나누어 담당한다.

# 연결 관리자

연결 관리자의 역할은 두 컴퓨터 사이의 연결을 추상화 하는 것이다. 윗단의 스트림 관리자가 내려주는 데이터를 받아 아랫단인 플랫폼 패킷 모듈로 전달한다.

연결 관리자 수준에서도 여전히 신뢰성을 보장하지 않는다. 데이터를 책임지고 전달해 주지는 않는다는 것이다.
대신 연결 관리자는 DSN을 보장하는데, 쉬운 말로 하자면 맡긴 패킷이 전달되었느닞 여부까지만 연결 관리자가 확실히 알려준다는 뜻이다.
이러한 상태 통지를 확인하면 상위 계층 관리자(스트림 관리자)는 특정 데이터가 무사히 전달 되었는지 판단할 수 있다.

배달 상태 통지는 수신 측의 확인 응답에 따라 비트 필드를 이용한 슬라이딩 윈도우 기법으로 구현된다.
트라이브스의 네트워킹 모델을 서술한 원논문에선 연결 관리자를 구현하는 상세한 내용은 다루지 않았지만, 우리는 7장에서 이 같은 시스템을 구현해보자.

# 스트림 관리자

스트림 관리자가 주로 하는 일은 다른 여러 상위 관리자를 대신하여 데이터를 연결 관리자에 보내는 것이다. 이때 중요한 처리는 바로 허용 최대 데이터 전송률을 조절하는 것이다.
전송률은 인터넷 연결 품질에 좌우된다. 트라이브스의 논문에선 사용자가 28.8kbps 모뎀을 쓰는 경우 초당 10패킷에 패킷당 200바이트, 곱하면 대략 초당 2킬로바이트 정도로 패킷 전송률을 잡는 예를 들고 있다.
최대 전송 빈도와 크기는 서버에 접속할 때 클라이언트가 알려주는데, 서버가 데이터를 너무 많이 보내 과부하를 주지 않도록 하기 위함이다.

여러 시스템이 각자 스트림 관리자에 데이터 전송을 요청하므로, 이들 요청의 우선순위를 관리하는 것도 스트림 관리자의 역할이다.
대역폭이 제한된 상황에선 이동 관리자, 이벤트 관리자, 고스트 관리자의 요청이 최우선으로 처리된다.스트림 관리자는 어떤 데이터를 보낼지 결정한 다음 패킷을 꾸려 연결 관리자에 내려보낸다. 
이어서 스트림 관리자는 전송을 요청했던 상위 관리자들에게 각자의 데이터가 잘 전달되었는지를 알려준다.

전송 주기와 패킷 크기를 스트림 관리자가 결정하므로, 한 패킷에 여러 종류의 데이터를 섞어 보내는 경우가 다반사이다. 
이를테면 패킷 하나를 열었을 때 이동 관리자의 데이터가 일부, 이벤트 관리자의 데이터도 일부, 거기에 고스트 관리자의 데이터도 약간, 이런식이다.

# 이벤트 관리자

이벤트 관리자는 게임 시뮬레이션 중 발생하는 이벤트의 대기열을 관리한다. 이들 이벤트는 일종의 간이 RPC로 여기면 된다.
RPC란 호출 시 원격 머신에서 실행되는 함수 또는 프로시저를 뜻한다. RPC에 대한 상세한 내용은 5장에서 다룬다.

예를 들어 플레이어가 총을 쏠 때 관련 시스템이 player_fired라는 이벤트를 이벤트 관리자에 보낸다. 그러면 관리자가 서버에 해당 이벤트를 보내는데, 서버는 이를 받아 검증한 후 실제 사격을 처리한다.
이벤트의 우선순위를 매기는 것은 이벤트 관리자의 권한으로, 가장 우선순위가 높은 이벤트부터 기록해 나가다가 특정 조건이 되면 처리를 중단한다.
구체적으로는 패킷이 꽉차거나 이벤트 큐가 비었을 때 혹은 현재 계류 중인 이벤트가 너무 많은 경우가 여기에 해당한다.

이벤트 관리자는 각 이벤트의 전송 기록을 추적하여 이벤트의 확실한 전달을 보장한다. 이때 전달을 보장하는 방법은 아주 간단하다.
보장하려는 이벤트의 확인응답이 없으면 대기열 맨 앞에 해당 이벤트를 다시 한번 끼워 넣어 보내면 된다.
물론 전달을 굳이 보장할 필요가 없는 이벤트도 있을 텐데, 이런 이벤트는 아예 전송 기록 추적조차 하지 않는다.

# 고스트 관리자가

고스트 관리자야 말로 128인 멀티플레이를 실현하는 데 있어 가장 중요한 시스템이다.
상위 수준에서 고스트 관리자가 하는 일은 바로 특정 클라이언트에게 유의미하다고 여겨지는 동적 객체를 복제 혹은 '고스트' 사본을 만드는 것이다.
무슨 뜻이냐면 클라이언트가 서버에서 받아둔 여러 객체 정보를 일컬어 클라이언트상 서버 객체의 '고스트'라 칭하는데, 이 고스트를 전송 또는 수신하는 것이 고스트 관리자의 역할이다.
클라이언트에 객체 정보를 보낼 때 고스트 관리자는 그 클라이언트에 딱 필요한 정보만 걸러서 보낸다. 클라이언트가 어떤 내용을 '반드시 파악'하고 있어야 하는지, 그리고 어떤 내용을 '알아 두어야' 할지는 게임의 시뮬레이션 계층이 책임지고 판단한다.
이에 따라 게임 객체에 고유한 우선순위가 부여되는데, '반드시 파악' 해야 하는 객체는 높은 우선순위로, '알아 두어야'하는 정도라면 후순위로 부여된다.
어떤 객체가 클라이언트의 인지 범위에 포함되는지, 즉 스코프에 포함되는지 여부를 판정하는 데는 몇 가지 서로 다른 접근 방법이 있다.
9장에서 이들 방법에 대해 다루지만, 대체로 판정법은 게임마다 매우 상이한 편이다.

어떤 방식으로든 유의미한 객체 집합을 일단 계산하고 난 다음에 고스트 관리자가 하는 일은 서버에서 클라이언트로 가능한 많은 객체 상태를 전송하는 것이다.
모든 클라이언트가 가장 최신의 상태로 업데이트 되어 있게끔 보장하는 것은 고스트 매니저의 중요한 책무이다. 
고스트의 최신 상태가 왜 중요하냐면 클라이언트가 내려받은 서버 객체에 대한 '고스트'에는 체력, 무기, 탄환 개수 등 그 정보가 최신이 아니면 쓸모없는 종류의 데이터가 포함되기 때문이다.

어떤 객체가 스코프에 포함되면, 고스트 관리자는 고스트 레코드라는 그럴싸한 이름의 부가 정보를 객체에 할당하는데, 이는 고유ID, 상태 마스크, 우선순위, 상태 변경 여부 등 항목으로 구성된다.
고스트 레코드의 전송 순서는 일차로 객체의 상태가 변경된 것 먼저, 그 다음으로 레코드 자체의 우선순위에 따른다. 객체의 전송 여부가 결정되면 이들 데이터를 내보낼 패킷에 추가하는데, 그 방식은 대체로 5장에서 다룰 방법과 유사하다.

# 이동 관리자

이동 관리자의 역할은 플레이어의 이동 데이터를 최대한 빨리 전송하는 것이다.
템포가 빠른 멀티플레이어 게임을 즐겨본 독자라면, 이러한 장르의 게임에서 정확한 이동 정보가 치명적 요소라는데 충분히 공감할 것이다.
적 플레이어의 위치 정보가 더디게 수신되면 아무리 정조준해서 사격해도 목표의 현재 위치 대신 과거 위치에 대고 사격하는 꼴이며, 이는 실제로 겪어보면 그저 황당할 따름이다. 레이턴시를 줄여 플레이어가 지연을 느끼지 못할 정도로 이동 정보를 빠르게 갱신해 줘야 한다.

이동 관리자는 초당 30프레임의 빠른속도로 입력 캡처를 수행하여 데이터를 생성하는데, 이 데이터에는 높은 우선순위가 부여된다. 1초에 30건씩 입력 정보가 쌓이므로, 이 중에서 가장 최신의 정보를 가능한 한 빨리 보내줘야 하기 때문이다. 
이동 데이터를 내려보내면 스트림 관리자는 다른 것보다 가장 먼저 이동 데이터를 챙겨 내보낼 패킷 앞에 끼워 보내는데, 이동 데이터의 우선순위가 가장 높기 때문에 이렇게 동작하는 것이다. 각 클라이언트의 이동 관리자는 이 같은 방식으로 각자 자신의 이동 정보를 서버에 송신해야 한다.
아울러 서버는 수신한 정보를 게임 시뮬레이션에 반영하고, 클라이언트에게 이동 정보를 잘 받았다고 확인응답해 주어야 한다.

# 기타 시스템

트라이브스 모델에는 그밨의 시스템도 몇몇 있는데, 전체 비중으로 볼때 그다지 중요치는 않은 것들이다.
데이터블록 관리자 가 그 예인데, 비교적 정적인 편에 속하는 게임 객체의 전송을 취급한다. 이와 구별하여 보다 동적인 객체는 고스트 관리자가 담당한다.
포탑이 바로 정적인 객체의 좋은 예로, 실제 이동하는 일은 없으므로 동적인 객체로 구분하지는 않지만, 플레이어가 상호작용하여 상태 갱신이 일어나는 객체다.
