1. 다음 글에서 프로세스와 프로그램 중에서 선택하라.
```markdown
( 프로그램 )은(는) 컴파일되어 실행 가능한 형태로 저장 장치에 저장된 상태일 때 부르는 용어이며,
( 프로세스 )은(는) 메모리에 적재되어 실행 중인 상태일 때 부르는 용어이다.
```
---
2. 프로세스의 특징을 설명한 것 중 맞는 것은?
- [ ] 프로세스에게는 정수 번호가 하나씩 할당되지만, 같은 번호를 가지는 프로세스가 존재할 수 있다.
- [ ] 부모 프로세스와 자식 프로세스는 데이터 공간을 공유하므로 통신이 편리하다.
- [ ] 프로세스를 실행시키고, 대기시키고, 종료시키는 관리는 모두 응용프로그램에 의해 이루어진다.
- [x] **프로세스를 스케줄링하는 것은 커널의 기능이다.**
---
3. 프로세스에 대한 설명으로 틀린 것은?
- [x] **동일한 프로그램이 실행되어 생성된 프로세스는 항상 동일한 프로세스 번호를 할당받는다.**
  - 동일한 프로그램이라도 실행될 때마다 다른 프로세스 번호를 할당 받는다.
- [ ] 프로세스 번호로 프로세스를 구분한다.
- [ ] 프로세스 사이에는 부모 자식 관계 가 있다.
- [ ] 커널은 프로세스마다 각각 PCB 구조체를 두고 프로세스의 정보를 별도로 관리한다.
---
4. PCB에 들어 있는 정보가 아닌 것은?
- [ ] 프로세스 컨텍스트
- [ ] 프로세스 번호
- [ ] 부모 프로세스 번호
- [x] **프로세스 이름**
---
5. 프로세스의 종료코드는 어디에 저장되는가?
- [ ] 프로세스의 PCB
- [x] **커널 스택**
- [ ] 사용자 스택
- [ ] 부모 프로세스의 PCB
---
6. 프로세스가 종료될 때, 커널이 프로세스 테이블 항목이나 PCB를 즉각 삭제하지 않는 이유는 무엇인가?
- [ ] 얼마 지나지 않아 사용자가 동일한 프로그램을 실행시킬 것을 대비하여
- [x] **프로세스 종료코드를 부모 프로세스가 읽어갈 때까지 기다리기 위해**
  - 부모 프로세스가 자식 프로세스의 종료 상태를 확인할 수 있도록 종료코드 유지
- [ ] 약간의 시간 지연을 통해 커널 데이터를 동기화시키기 위해
- [ ] 프로세스가 종료한 뒤, 사용자가 undo 명령을 내릴 것을 대비하기 위해
---
7. 32비트 CPU에 대해 다음에 답하여라.

(1) CPU의 주소선 개수는?
 - 32개
   
(2) CPU가 액세스 가능한 메모리의 최대량은?
 - 4GB (2^32 = 4GB)
   
(3) 이 CPU를 사용할 때 프로세스의 주소 공간 크기는?
 - 4GB
---
8. 프로세스의 주소 공간에 대한 설명으로 맞는 것은?
- [x] **프로세스가 실행되는 동안 접근할 수 있는 메모리의 최대 범위이다.**
  - 프로세스의 주소 공간은 가상 메모리 공간이며, 커널 공간도 포함될 수 있다.
- [ ] 프로세스의 주소 공간은 물리 공간이다.
- [ ] 프로세스의 주소 공간에는 커널 공간이 포함되지 않고 사용자 공간만 포함한다.
- [ ] 프로세스에서 발생한 주소 100번지는 물리 메모리 100번지이다.
---
9. 프로세스가 메모리에 적재될 때 프로세스를 구성하는 4개의 영역은 무엇인가?
 **코드 영역, 데이터 영역, 힙, 스택**
---
10. 운영체제는 프로세스를 코드, 데이터, 힙, 스택의 4 영역으로 구성한다. 다음은 어느 영역에 형성되는가?
- 전역변수 **데이터 영역**
- 지역변수 **스택**
- C++에서 new 연산자나 C 프로그램에서 malloc() 함수를 호출하여 할당받은 메모리 **힙**
- 사용자가 작성한 함수 코드 **코드 영역**
- 라이브러리에 작성된 함수 코드 **코드 영역**
- 라이브러리 함수에 선언된 지역 변수들 **스택**
---
11. 프로세스가 적재된 이후 실행 과정 동안 크기가 변하지 않는 영역을 있는 대로 골라라?
- [x] **코드 영역**
  - 읽기 전용이며, 크기가 변하지 않음
- [ ] 데이터 영역
- [ ] 힙
- [ ] 스택
---
12. prinf()는 C프로그램에서 화면 출력을 위해 사용되는 C 표준 라이브러리 함수이다. 다음 질문에 답하라.

(1) printf() 함수의 코드는 프로세스의 코드 영역에 포함되는가?
 - **넵**

(2) printf() 함수 내에 선언된 지역 변수들은 프로세스의 어느 영역에 포함되는가?
- [ ] 프로세스의 영역에 포함되지 않는다.
- [ ] 데이터 영역
- [ ] 힙
- [x] **스택**

(3) printf() 함수의 코드와 지역 변수들은 사용자 공간에 적재되는가, 커널 공간에 적재되는가?
 - **사용자 공간에 적재된다.**
---
13. 프로세스의 주소 공간은 0버지부터 시작되어 연속적인 번지로 이루어진다. 만일 3개의 프로세스가 메모리에 적재된채 동시에 실행된다고 하면, 모든 프로세스가 0번지에서 시작하므로, 프로세스들 사이에 번지 충돌이 발생하고 메모리 충돌이 발생할 것 같다. 운영체제는 어떻게 이 문제를 해결하는가?

- **가상메모리를 사용하여 각 프로세스는 독립적인 가상 주소 공간을 갖는다. 운영체제는 가상 주소를 실제 물리 메모리 주소로 변환하여 프로세스 간에 충돌이 발생하지 않도록 한다.**
---
14. 프로세스 스케줄링에는 어떤 상태의 프로세스들이 대상이 되는가?
- [x] **Ready 상태**
      - Ready 상태의 프로세스들이 스케줄링 대상이 된다.
- [ ] Ready 상태와 Blocked 상태
- [ ] New 상태와 Ready 상태, 그리고 Blocked 상태
- [ ] 어떤 상태에 있든 상관없이 모든 프로세스
---
15. 커널은 현재 실행 중인 프로세스가 입출력을 요청하면 어떤 상태로 전이시키는가?
- [ ] Ready 상태
- [x] **Blocked 상태**
- [ ] Zombie 상태
- [ ] 전이시키지 않는다.
---
16. 프로세스는 실행 중 다음 각 경우에 어떤 상태로 바뀌는가?

(1) yield() 시스템 호출을 불러 스스로 실행을 중단하고 다른 프로세스에게 양보할 때
- **Ready 상태**
  
(2) sleep(1) 시스템 호출을 불러 1초동안 잠을 잘 때
- **Blocked 상태**

(3) exit(-1) 시스템 호출을 불러 종료할 때
- **Zombie 상태**

(4) 프로세스에게 할당된 타임 슬라이스가 다 되었을 때
- **Ready 상태**
---
17. PCB 내에 프로세스가 열어 놓은 파일에 관한 정보가 저장되는 것으로 미루어 다음중 틀리게 설명한 것은?
- [ ] 프로세스가 종료할 때, 닫지 않는 모든 파일을 커널이 자동으로 닫는다.
- [ ] 프로세스에 속한 모든 스레드들이 프로세스에 열려 있는 파일에 입출력 할 수 있다.
- [ ] 열어 놓은 파일은 프로세스 별로 관리된다.
- [x] **한 프로세스가 열어 놓은 파일을 다른 프로세스가 입출력할 수 있다.**
   - 프로세스간 파일 공유는 특별한 경우에만 허용
---
18. 다음 중 자식 프로세스를 생성하는데 사용되는 시스템 호출은?
- [x] **fork()**
- [ ] exec()
- [ ] exit()
- [ ] create()
---
19. wait() 시스템 호출에 대해 잘 설명한 것은?
- [x] **자식 프로세스가 종료할 때까지 대기한다.**
- [ ] 요청한 입출력이 종료할 때까지 대기한다.
- [ ] 일정할 시간이 흐를 때까지 대기한다.
- [ ] 부모 프로세스가 종료할 때까지 대기한다.
---
20. 부모 프로세스가 wait() 시스템 호출을 부르기 전, 자식 프로세스가 먼저 종료할 때 상황에 맞게 설명된 것은?
- [x] **커널은 자식 프로세스를 좀비 프로세스로 만든다.**
- [ ] 커널은 부모 프로세스에게 신호를 보내고 자식 프로세스를 제거한다.
- [ ] 커널은 자식 프로세스를 종료시키지 않고 부모 프로세스가 wait()을 호출할 때까지 대기시킨다.
- [ ] 자식 프로세스에 오류가 발생하고 비정상 종료된다.
---
21. 좀비 상태의 프로세스에 대한 설명 중 틀린 것은?
- [x] **좀비 프로세스는 시스템의 성능을 심각하게 떨어뜨린다.**
   - 좀비 프로세스는 메모리와 자원을 반환한 상태이기에 시스템 성능에 큰 영향을 미치지 않는다.
- [ ] 좀비 프롯세ㅡ는 코드, 데이터, 힙, 스택 등 할당 방은 메모리와 모든 자원이 반환된 상태이다.
- [ ] PCB는 커널 내에 여전히 존재한다.
- [ ] 프로세스 테이블의 항목이 제거되지 않고 있다.
---
22. 유닉스 계열의 운영체제에서 #1 프로세스를 무엇이라고 부르는가?
- [ ] swapper
- [x] **init 프로세스**
    - 시스템의 첫 번째 프로세스이자 다른 모든 프로세스의 부모 프로세스
- [ ] idle 프로세스
- [ ] pager 프로세스
---
23. 유닉스 계열의 운영체제에서 모든 사용자 프로세스의 조상은 누구인가?
- **init 프로세스**
---
24. Windows에서 #0 프로세스인 시스템 유휴 프로세스나 리눅스의 #0 idle 프로세스의 역할은 무엇인가?
- **CPU가 유휴 상태일 때 CPU 자원을 최소한으로 소비하는 역할**
---
25. 다음은 어떤 프로세스를 설명하느지 적어라.
- 부모 프로세스가 먼저 종료한 자식 프로세스 **고아 프로세스**
- 종료할 때 종료 코드를 남겨 놓았지만 부모 프로세스가 읽어가지 않고 있을때, 종료한 자식 프로세스  **좀비 프로세스**
- 입출력 작업이 계산 작업보다 월등히 많은 프로세스  **I/O 바운드 프로세스**
- 계산 작업이 입출력 작업보다 월등히 많은 프로세스 **CPU 바운드 프로세스**
- 사용자와 대화가 필요하지 않고 낮은 우선순위로 실행되는 프로세스 **배치 프로세스**
---
26. 시스템에 무한히 많은 프로세스가 생성되지 못하느 이유가 구체적으로 무엇일까?
 - **프로세스 테이블의 크기가 한정되어 있기 떄문** 테이블이 꽉차면 더이상 프로세스 생성 불가
---
27. main()에서 3을 리턴하느 three 라는 프로그램을 작성하였다. 쉘에서 다음과 같이 실행시키면, main()에서 리턴한 값 3은 누구에게 전달되는가?

```bash
$ ./three
$
```

- [ ] 커널
- [ ] init 프로세스
- [x] **쉘**
- [ ] 부모 프로세스가 없기 때문에 아무에게도 전달되지 않는다.
---
28. 종료코드의 목적은 무엇인가?
- [ ] 프로세스가 어떤 상태로 종료함을 커널에게 전달하기 위해
- [x] **프로세스가 어떤 상태로 종료함을 부모 프로세스에게 전달하기 위해**
- [ ] 프로세스가 어떤 상태로 종료함을 디스크에 기록해두기 위해
- [ ] 프로세스가 오류로 종료하는지 정상 종료하는지 커널에게 알리기 위해
