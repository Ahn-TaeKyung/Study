❑[첫 번째 섹션](#CH01)에서는 이 계층에서 제공하는 서비스를 정의하여 네트워크 계층을 소개합니다. 먼저 패킷화에 대해 설명합니다. 그런 다음 전달과 라우팅을 설명하고 두 가지를 비교합니다. 그런 다음 이 섹션에서는 흐름, 오류 및 혼잡 제어와 같은 다른 서비스에 대해 간략하게 설명합니다.

❑[두 번째 섹션](#CH02)에서는 네트워크 계층에서 발생하는 패킷 스위칭에 대해 설명합니다. 이 섹션에서는 데이터그램 접근 방식과 패킷 스위칭의 가상 회로 접근 방식에 대해 자세히 설명합니다.

❑[세 번째 섹션](#CH03)에서는 네트워크 계층 성능에 대해 설명합니다. 네트워크 계층 통신에서 발생하는 다양한 지연에 대해 설명합니다. 패킷 손실 문제도 언급합니다. 마지막으로 네트워크 계층에서의 혼잡 제어 문제에 대해 설명합니다.

❑[네 번째 섹션](#CH04)에서는 네트워크 계층에서 가장 중요한 문제인 IPv4 주소 지정에 대해 설명합니다. 먼저 주소 공간에 대해 설명합니다. 그런 다음 과거에 속하지만 클래스리스 주소 지정을 이해하는 데 유용한 클래스풀 주소 지정에 대해 간략하게 설명합니다. 그런 다음 이 섹션에서는 클래스리스 주소 지정으로 이동하여 이 주제와 관련된 몇 가지 문제를 설명합니다. 그런 다음 조직에서 주소를 동적으로 할당하는 데 사용할 수 있는 DHCP(Dynamic Host Configuration Protocol)에 대해 설명합니다. 마지막으로 이 섹션에서는 주소 부족을 어느 정도 해결하는 데 사용할 수 있는 NAT(NetworkAddressResolution)에 대해 설명합니다.

❑[다섯 번째 섹션](#CH05)에서는 네트워크 계층 패킷의 포워딩에 대해 설명합니다. 먼저 패킷의 대상 주소를 기반으로 포워딩을 수행할 수 있는 방법을 보여줍니다. 그런 다음 레이블을 사용하여 포워딩을 수행할 수 있는 방법에 대해 설명합니다.

# CH01
인터넷에서의 네트워크 계층에 대해 논의하기 전에, 일반적으로 네트워크 계층 프로토콜에서 기대되는 네트워크 계층 서비스에 대해 간단히 논의해 보겠습니다. 그림은 네트워크 계층에서 앨리스와 밥 사이의 통신을 보여줍니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/f12927f1-ad94-4840-8946-a3337ddde6ec" width="500"> 


- 송신에서 수신 호스트로 데이터그램 릴레이
  - sender: 세그먼트를 데이터그램으로 캡슐화하고 링크 계층으로 전달합니다
  - receiver : 프레임을 네트워크 계층 프로토콜로 전달

- 모든 인터넷 장치의 네트워크 계층 프로토콜: 호스트, 라우터

- 라우터:
  - 이를 통과하는 모든 IP 데이터그램의 헤더 필드를 검사합니다
  - 데이터그램을 입력 포트에서 출력 포트로 이동하여 종단 경로를 따라 데이터그램을 전송합니다


- 네트워크 계층의 첫 번째 의무 : 확실한 패킷화
소스에서 네트워크 계층 패킷에 페이로드를 캡슐화하고 목적지에서 네트워크 계층 패킷에서 페이로드를 캡슐화 해제합니다. 즉, 네트워크 계층의 한 가지 의무는 페이로드를 변경하거나 사용하지 않고 소스에서 목적지로 운반하는 것입니다. 네트워크 계층은 내용을 변경하거나 사용하지 않고 송신자에서 수신자로 패키지를 배달하는 역할을 하는 우체국과 같은 통신사의 서비스를 수행합니다.

- 두 번째 의무 : routing 과 forwarding
포워딩: 라우터의 입력 링크에서 적절한 라우터 출력 링크로 패킷 이동

라우팅: 소스에서 대상으로 패킷이 이동하는 경로 결정

### 3줄 요약
1. 정보를 보낼때 정보를 5단계로 나뉘어서 보냄
2. 이때 Network 레이어 이상은 건들이지 않고 아래 정보만 바뀜 : 패킷화
3. 나 일로 보내줘! 가 포워딩 / 그럼 이렇게 가! 가 라우

# CH02
앞 절의 라우팅과 포워딩에 대한 논의에서 네트워크 계층에서 일종의 스위칭이 일어난다는 것을 추론합니다. 사실 라우터는 전기 스위치가 입력을 출력에 연결하여 전기가 흐르도록 하는 것처럼 입력 포트와 출력 포트(또는 출력 포트 집합) 사이에 연결을 생성하는 스위치입니다.
___
### datagram 접근법
인터넷이 시작되었을 때, 쉽게 만들기 위해서, 네트워크 계층은 네트워크 계층 프로토콜이 각 패킷을 독립적으로 취급하고, 각 패킷은 다른 패킷과 아무런 관계가 없는 무연결 서비스를 제공하도록 설계되었습니다. 그 아이디어는 네트워크 계층이 소스에서 목적지까지의 패킷 전달만을 담당한다는 것이었습니다. 이 접근 방식에서, 메시지의 패킷들은 그들의 목적지까지 같은 경로로 이동할 수도 있고, 이동하지 않을 수도 있습니다. 

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/bf7b4c26-623f-4d0c-8437-f9f6d85c7e0f" width="500"> 


그림과 같이 보낸 순서와 받는 순서가 달라지는 일이 발생할 수 있습니다. 그래서 생긴것이
### virtual-circuit 접근법
연결 지향 서비스(가상 회로 접근법이라고도 함)에서는 메시지에 속하는 모든 패킷 간에 관계가 있습니다. 메시지의 모든 데이터그램을 보내기 전에 데이터그램의 경로를 정의하기 위해 가상 연결을 설정해야 합니다. 연결 설정 후에는 데이터그램이 모두 동일한 경로를 따를 수 있습니다. 이러한 유형의 서비스에서는 패킷이 소스 및 대상 주소를 포함해야 할 뿐만 아니라 패킷이 따라야 할 가상 경로를 정의하는 가상 회로 식별자인 흐름 레이블도 포함해야 합니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/cc6dc56c-8996-4e0e-844c-1087ff053ce4" width="500"> 


그림과 같이 경로를 지정해 두는 방식입니다.

방식을 바꾸면서 라우터의 입출력 내용도 변화가 생겼습니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/95108caa-80a7-4cfc-a41c-74a47a1ae947" width="500"> 


<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/e17623bc-bfb6-40c5-a330-38c4554d08dc" width="500"> 


그림과 같이 라우터마다 라벨을 붙이고 어디서 왔고 어디로 갈지를 다 표시하게 됐습니다.

# CH03
네트워크 계층의 서비스를 이용하는 상위 계층 프로토콜들은 이상적인 서비스를 제공받기를 기대하지만 네트워크 계층은 완벽하지 않습니다. 네트워크의 성능은 지연, 처리량, 패킷 손실 등으로 측정될 수 있습니다.
___
## delay
우리 모두는 네트워크의 즉각적인 응답을 기대하지만, 소스에서 목적지까지의 패킷은 지연에 직면합니다. 네트워크의 지연은 전송 지연, 전파 지연, 처리 지연, 대기열 지연의 네 가지 유형으로 나눌 수 있습니다. 먼저 이 각 지연 유형에 대해 논의한 다음 소스에서 목적지까지의 패킷 지연을 계산하는 방법을 보여드리겠습니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/b890d83b-ac6b-4433-a889-54eea5814e1f" width="500"> 


1. d_prop
전파시간 - 소스에서 목적지까지 비트가 이동하는데 필요한 시간
거리 / 전파 속도
2. d_trans
전송시간 - 메시지를 보낼때 첫 번째 비트는 전파시간과 동일한 시간이 걸릴 것이다. 물론 마지막 비트도 동일한 시간이 걸릴 수도 있다
   하지만, 첫 번째 비트와 마지막 비트 사이에 시간이 있다.
메시지 크기 / 대역폭
3. d_queue
대기열시간 - 각 중간 또는 종료 장치는 메시지가 처리되기 전에 메시지를 보류한다.
네트워크에 부과되는 부하에 따라 변경된다
4. d_proc
가공시간 - 연산시간
CPU 처리능력에 따라 천차만별

## 처리량
트워크의 임의의 지점에서의 처리량은 그 지점을 1초 안에 통과하는 비트 수로 정의되며, 이것은 실제로 그 지점에서의 데이터 전송률입니다. 소스에서 목적지까지의 경로에서 패킷은 각각 다른 전송률을 가진 여러 링크(네트워크)를 통과할 수 있습니다. 그러면 우리는 전체 경로의 처리량을 어떻게 결정할 수 있을까요? 상황을 보기 위해 그림 2.10과 같이 각각 다른 전송률을 가진 세 개의 링크가 있다고 가정해봅시다

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/86d0b126-8c99-44ea-b9c8-9e8a416fcf40" width="500"> 

## 패킷로스
통신 성능에 심각한 영향을 미치는 또 다른 문제는 전송 중 손실되는 패킷의 수입니다. 라우터에서 다른 패킷을 처리하는 중에 패킷을 수신하면 수신된 패킷은 순서를 기다리며 입력 버퍼에 저장되어야 합니다. 그러나 라우터에는 제한된 크기의 입력 버퍼가 있습니다. 버퍼가 가득 차서 다음 패킷을 떨어 뜨려야 하는 때가 올 수 있습니다. 인터넷 망 계층에서 패킷 손실의 영향은 패킷이 다시 발생해야 하고, 이는 다시 오버플로우를 발생시켜 더 많은 패킷 손실을 초래할 수 있습니다.

# CH04
TCP/IP 프로토콜 스위트의 IP 계층에서 각 기기의 인터넷 연결을 식별하기 위해 사용하는 식별자를 인터넷 주소 또는 IP 주소라고 합니다. IPv4 주소는 32비트 주소로 호스트나 라우터의 인터넷 연결을 고유하고 보편적으로 정의합니다. IP 주소는 연결의 주소이지 호스트나 라우터가 아닙니다.
___
## 주소 공간
주소를 정의하는 IPv4와 같은 프로토콜에는 주소 공간이 있습니다. 주소 공간은 프로토콜에서 사용하는 총 주소의 수입니다. 프로토콜에서 주소를 정의할 때 b비트를 사용하면 각 비트에 서로 다른 두 개의 값(0 또는 1)이 있으므로 주소 공간은 2^b입니다. IPv4는 32비트 주소를 사용하므로 주소 공간은 2^32 또는 4,294,967,296(40억 이상)입니다. 제한이 없다면 40억 개 이상의 장치를 인터넷에 연결할 수 있습니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/314f435c-69e4-4295-8ba5-bffed020d8d9" width="500"> 


## 클래스별 주소지정
인터넷이 시작되었을 때 IPv4 주소는 고정 길이 접두사로 설계되었지만, 소형 네트워크와 대형 네트워크를 모두 수용하기 위해 하나(n = 8, n = 16, n = 24) 대신 3개의 고정 길이 접두사가 설계되었습니다. 전체 주소 공간은 그림 18.18과 같이 5개의 클래스(클래스 A, B, C, D, E)로 구분되었습니다. 이 방식을 클래스별 주소 지정(classfly addressing)이라고 합니다. 클래스별 주소 지정은 과거에 속하지만, 나중에 논의할 클래스리스 주소 지정을 이해하는 데 도움이 됩니다.

<img src="https://github.com/Ahn-TaeKyung/Study/assets/154008745/699ebdf6-28ca-4aa6-86a5-00239ee3a500" width="500"> 


## 클래스리스 주소지정
인터넷의 성장에 따라 장기적인 해결책으로 더 큰 주소 공간이 필요하다는 것은 분명했습니다. 그러나 주소 공간이 더 커지면 IP 주소의 길이도 증가해야 하는데, 이는 IP 패킷의 형식을 변경해야 한다는 것을 의미합니다. 장거리 해결책은 이미 고안되어 IPv6라고 불리지만, 같은 주소 공간을 사용하되 각 조직에 공평한 공유를 제공하기 위해 주소의 분포를 변경하는 단기 해결책도 고안되었습니다. 단기 해결책은 여전히 IPv4 주소를 사용하지만, 이를 클래스리스 주소 지정 또는 CIDR(Classless Inter-Domain Routing)이라고 합니다

https://github.com/Ahn-TaeKyung/Study/assets/154008745/764cb7a8-71e4-43af-bcc1-2cf54b10f3d6

